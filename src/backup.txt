import Peer, { DataConnection } from "peerjs";
import { createSignal } from "solid-js";
import { Vector, add, sub, mul, dot, abs } from "./physics";

const HOST_PEER_ID = "dbd71e16-01c9-43f1-a75b-e916ddc60e10";

type Racket = {
  pos: Vector;
  lastPos: Vector;
};
type Puck = {
  pos: Vector;
  speed: Vector;
};
type DataSent = {
  playerRackets: Racket[];
  puck: Puck;
};
function App() {
  const RacketRadius = 0.06,
    PuckRadius = 0.03,
    TableWidth = window.innerWidth,
    MaxSpeed = TableWidth * 0.0075,
    MinSpeed = 0.1;
  var conn: DataConnection, hostConn: DataConnection;
  const [rackets, setRackets] = createSignal<Racket[]>([
    {
      pos: { x: 100, y: 100 },
      lastPos: { x: 100, y: 100 },
    },
    {
      pos: { x: TableWidth - 100, y: 100 },
      lastPos: { x: TableWidth - 100, y: 100 },
    },
  ]);
  const [scores, setScores] = createSignal({ scoreA: 0, scoreB: 0 });
  const [puck, setPuck] = createSignal<Puck>({
    pos: {
      x: TableWidth * 0.5,
      y: TableWidth * 0.3,
    },
    speed: {
      x: 0.000001,
      y: 0.000001,
    },
  });

  const userType = window.location.hash.slice(1);
  console.log(userType);

  if (userType == "host") {
    const peer = new Peer(HOST_PEER_ID);
    peer.on("open", () => {
      peer.on("connection", (c) => {
        conn = c;
        c.on("data", (data) => {
          setRackets((data as DataSent).playerRackets);
          setPuck((data as DataSent).puck);
        });
      });
    });
  } else {
    // Guest
    const peer = new Peer();
    peer.on("open", (id) => {
      hostConn = peer.connect(HOST_PEER_ID);
      hostConn.on("open", () => {
        hostConn.on("data", (data) => {
          setRackets((data as DataSent).playerRackets);
          setPuck((data as DataSent).puck);
        });
      });
    });
  }

  function updateRacket(idx: number, newX: number, newY: number) {
    let prevRackets = rackets();
    if (idx == 0) {
      newX = Math.min(
        TableWidth * 1,
        Math.max(TableWidth * (0.03 + RacketRadius), newX)
      );
    } else {
      newX = Math.min(
        TableWidth * (1 - 0.03 - RacketRadius),
        Math.max(TableWidth * 0.5, newX)
      );
    }
    newY = Math.min(
      TableWidth * (0.567 - RacketRadius),
      Math.max(TableWidth * (0.03 + RacketRadius), newY)
    );
    prevRackets[idx] = {
      pos: { x: newX, y: newY },
      lastPos: { x: prevRackets[idx].pos.x, y: prevRackets[idx].pos.y },
    };
    setRackets(prevRackets);
  }
  function handleMouseMove(event: MouseEvent) {
    event.preventDefault();
    if (userType == "host") {
      updateRacket(0, event.clientX, event.clientY);
      conn.send({ playerRackets: rackets(), puck: puck() });
    } else if (userType == "guest") {
      updateRacket(1, event.clientX, event.clientY);
      hostConn.send({ playerRackets: rackets(), puck: puck() });
    }
  }
  function distance(a: Vector, b: Vector) {
    return Math.sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
  }
  function colide(idx: number) {
    return (
      distance(rackets()[idx].pos, puck().pos) <=
      TableWidth * (RacketRadius + PuckRadius)
    );
  }
  function handleColision(idx: number) {
    if (colide(idx)) {
      let r = rackets()[idx];
      let d = distance(r.pos, puck().pos);
      let norm: Vector = mul(sub(puck().pos, r.pos), 1 / d);
      let newDir: Vector = add(
        puck().speed,
        mul(
          norm,
          -2 * dot(sub(puck().speed, mul(sub(r.pos, r.lastPos), 0.6)), norm)
        )
      );
      console.log(
        abs(norm),
        abs(add(puck().speed, sub(r.pos, r.lastPos))),
        abs(
          add(
            add(puck().speed, sub(r.pos, r.lastPos)),
            mul(norm, -2 * dot(add(puck().speed, sub(r.pos, r.lastPos)), norm))
          )
        )
      );
      if (abs(newDir) >= MaxSpeed) {
        newDir = mul(newDir, MaxSpeed / abs(newDir));
      } else if (abs(newDir) <= MinSpeed && abs(newDir) != 0) {
        newDir = mul(newDir, MinSpeed / abs(newDir));
      }
      setPuck({
        pos: add(
          puck().pos,
          mul(norm, TableWidth * (PuckRadius + RacketRadius) - d)
        ),
        speed: newDir,
      });
    }
  }

  function movePuck() {
    setPuck({
      pos: add(puck().pos, puck().speed),
      speed: puck().speed,
    });
    if (
      puck().pos.x <= (0.03 + PuckRadius) * TableWidth ||
      puck().pos.x >= TableWidth * (1 - 0.03 - PuckRadius)
    ) {
      if (
        puck().pos.y >= 0.194 * TableWidth &&
        puck().pos.y <= 0.403 * TableWidth
      ) {
        if (puck().pos.x <= 0.5 * TableWidth) {
          setScores({ scoreA: scores().scoreA, scoreB: scores().scoreB + 1 });
        } else {
          setScores({ scoreA: scores().scoreA + 1, scoreB: scores().scoreB });
        }
        setPuck({
          pos: {
            x: TableWidth * 0.5,
            y: TableWidth * 0.3,
          },
          speed: {
            x: 0.0000001,
            y: 0.0000001,
          },
        });
      } else {
        setPuck({
          pos: {
            x: Math.min(
              TableWidth * (1 - 0.03 - PuckRadius),
              Math.max(puck().pos.x, (0.03 + PuckRadius) * TableWidth)
            ),
            y: puck().pos.y,
          },
          speed: {
            x: -puck().speed.x * 0.9,
            y: puck().speed.y,
          },
        });
      }
    }
    if (
      puck().pos.y <= (0.03 + PuckRadius) * TableWidth ||
      puck().pos.y >= TableWidth * (0.567 - PuckRadius)
    ) {
      setPuck({
        pos: {
          x: puck().pos.x,
          y: Math.min(
            TableWidth * (0.567 - PuckRadius),
            Math.max(puck().pos.y, (0.03 + PuckRadius) * TableWidth)
          ),
        },
        speed: {
          x: puck().speed.x,
          y: -puck().speed.y * 0.9,
        },
      });
    }
    handleColision(0);
    handleColision(1);
  }
  setInterval(() => movePuck(), 1);

  return (
    <>
      <div
        onPointerDown={handleMouseMove}
        onPointerMove={handleMouseMove}
        class="w-full touch-none"
      >
        <img class="mb-1.5" src="src/images/white_table_complete.png" alt="" />
        <div
          class="absolute w-full"
          style={{
            top: `${puck().pos.y - window.innerWidth * PuckRadius}px`,
            left: `${puck().pos.x - window.innerWidth * PuckRadius}px`,
          }}
        >
          <img class="w-[6%]" src="src/images/puck.png" alt="what" />
        </div>
        <div
          class="absolute w-full"
          style={{
            top: `${rackets()[0].pos.y - window.innerWidth * RacketRadius}px`,
            left: `${rackets()[0].pos.x - window.innerWidth * RacketRadius}px`,
          }}
        >
          <img class="w-[12%]" src="src/images/red.png" alt="what" />
        </div>
        <div
          class="absolute w-full"
          style={{
            top: `${rackets()[1].pos.y - window.innerWidth * RacketRadius}px`,
            left: `${rackets()[1].pos.x - window.innerWidth * RacketRadius}px`,
          }}
        >
          <img class="w-[12%]" src="src/images/blue.png" alt="what" />
        </div>
        <div class="w-full h-24 grid grid-cols-2">
          <div class="text-3xl flex justify-center items-center h-full w-full bg-red-600 rounded-2xl">
            {scores().scoreA}
          </div>
          <div class="text-3xl flex justify-center items-center h-full w-full bg-blue-600 rounded-2xl">
            {scores().scoreB}
          </div>
        </div>
      </div>
    </>
  );
}

export default App;
